{"version":3,"sources":["../src/branch.js"],"names":[],"mappings":"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","file":"branch.js","sourcesContent":["import { fromJS, is, Map, List} from \"immutable\";\nimport debug from \"debug\";\nimport { toJS, isFunction, isPromise, insp, isObject } from \"./utils\";\nimport Slots from \"./slots\";\nconst d = debug(\"slt\");\nconst log = debug(\"slt:log\");\n\nclass Branch {\n    constructor(state, slots, ctx, parent = null) {\n        this.slots = slots;\n        this.state = state;\n        this.ctx = ctx;\n        this.parent = parent;\n        this.path = [];\n        this.value = null;\n        this.locks = {};\n    }\n\n    reset() {\n        this.state = this.initialState;\n    }\n\n    newBranch(state) {\n        let branch = new Branch(state, this.slots, this.ctx, this);\n        return branch;\n    }\n\n    setState(value) {\n        return this.set([], value);\n    }\n\n    set(path = [], value = {}, mergeValue = true) {\n        //({path, value} = this.reducePathAndValue(Slots.makePath(path), value));\n        path = Slots.makePath(path);\n        this.path = path;\n        this.value = value;\n        this.findAsync(new List (path), value);\n        if (Object.keys(this.locks).length) {\n            this.resolveAsync();\n            return;\n        }\n        log(\"SET %s TO %s\", insp(path), insp(value));\n        let state = this.state;\n        d(\"MERGED \\n%s\", insp(state));\n        const applyRules = (_path = new List(), _value = {}) => {\n            let rule = this.getSetRule(_path);\n            if (rule) {\n                let deps = this.getDeps(_path).map(dep => {\n                    let dependency = toJS(state.getIn(Slots.makePath(dep)));\n                    if (typeof dependency === \"undefined\") {\n                        console.log(state);\n                        throw new Error(\"Rule on `\" + _path.toArray().join(\".\") +\n                        \"` requires `\" + dep + \"` state dependency\");\n                    }\n                    return dependency;\n                });\n                log(\"RULE on path %s matched with value %s\", insp(_path), insp(_value));\n                state = Branch.mergeValue(state, _path, _value, mergeValue);\n                d(\"NEW BRANCH with state %s\", insp(state));\n                let branch = this.newBranch(state);\n                let result = rule.apply(branch, [_value, ...deps]);\n                d(\"RESULT is %s\", insp(result));\n                state = branch.state;\n                if (isPromise(result)) {\n                    log(\"PROMISE RETURNED\");\n                    result.bind(this.ctx); // out of call stack\n                    this.ctx.promises.push(result);\n                    result.then(() => {\n                        log(\"PROMISE FULFILLED for SET %s\", insp(_path));\n                        this.ctx.promises.splice(this.ctx.promises.indexOf(result), 1);\n                        this.ctx.slots._checkPromises(this);\n                    });\n                } else if (typeof result !== \"undefined\") {\n                    state = state.setIn(_path, result);\n                }\n            }\n            else {\n                if (isObject(_value)) {\n                    Object.keys(_value).forEach(k => applyRules(_path.push(k), _value[k]));\n                } else { // No rule found for this `set`\n                    state = Branch.mergeValue(state, path, value, mergeValue);\n                }\n            }\n        };\n        applyRules(new List(path), value);\n        this.state = state;\n        return this;\n    }\n\n    resolveAsync() {\n        Object.keys(this.locks).forEach((key) => {\n            let lock = this.locks[key];\n            lock.promise.then((result) => {\n                this.set(lock.path, result);\n                delete this.locks[key];\n            })\n        });\n    }\n\n    findAsync(path, value) {\n        if (isPromise(value)) {\n            this.locks[path] = {path, promise: value};\n        }\n        else if (isObject(value)) {\n            Object.keys(value).forEach(k => this.findAsync(path.push(k), value[k]));\n        }\n    }\n\n\n\n    reducePathAndValue(path, value) {\n        let i = path.length;\n        let v = value;\n        while (i--) {\n            let p = path.slice(0, i);\n            let tmp = {};\n            tmp[path.slice(i)] = v;\n            v = tmp;\n            if (this.getRule(p)) {\n                path = p;\n                value = v;\n            }\n        }\n        return { path, value }\n    }\n\n    getState() {\n        return this.state;\n    }\n\n    get(path = null, state = null) {\n        state = state || this.state;\n        if (!path) {\n            return state.toJS();\n        }\n        path = Slots.makePath(path);\n        let value = state.getIn(path);\n        return toJS(value);\n    }\n\n    getRule(path) {\n        return this.slots.getRule(path);\n    }\n\n    getSetRule(path) {\n        return this.slots.getSetRule(path);\n    }\n\n    getDeps(path) {\n        return this.slots.getDeps(path);\n    }\n\n    static mergeValue(state, path, value, mergeValue) {\n        return (isObject(value) && mergeValue) ?\n            state.mergeDeepIn(path, value) : state.setIn(path, value);\n    }\n}\n\nexport default Branch;"]}